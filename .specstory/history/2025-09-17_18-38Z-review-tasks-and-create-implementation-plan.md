<!-- Generated by SpecStory -->

# Review tasks and create implementation plan (2025-09-17 18:38Z)

_**User (2025-09-17 18:38Z)**_

You are a very senior engineer, expert in AI-first development, resilient, cloud-native systems.

Can you please review TASKS.md , purge whatever is unnecessary IN ANOTHER FILE called TASKS-CURSOR.md, review the repo and come up with a detailed implementation plan for the top three next tasks that would make this repo more resilient? Think hard

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Planning task review**

I need to look over TASKS.md and create a new file, TASKS-CURSOR.md, to purge unnecessary items. The user is asking for a curated version that only keeps what's essential without altering the original file. After that, I’ll review the repo and come up with a detailed implementation plan for the top three tasks that could enhance resilience. I’ll need to examine both TASKS.md content and the repo for potential improvements. The first task might involve adding health endpoints and graceful shutdown handling.
**Identifying top tasks**

I need to propose the top three tasks for enhancing resilience based on my review. These tasks include adding structured logging, implementing retry and circuit breaker patterns around dependencies like Kafka and databases, and considering the outbox pattern for publishing loan events. I also want to add test containers and end-to-end resilience tests, but I should focus on the top three first. I’ll read TASKS.md and the README to make sure my suggestions align with existing plans.</details></think>

---

I'll first scan the repository to read `TASKS.md` and related context, then create a new `TASKS-CURSOR.md` with a curated list. After that, I'll review the modules to propose the top three resilience tasks with detailed implementation plans.

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>**Planning repository improvements**

I need to review the existing TASKS.md and move unnecessary items to a new file named TASKS-CURSOR.md. This will create a curated list of actionable items. After that, I'll assess the current state of the repository to identify tasks that enhance resilience. I expect to focus on three major tasks, such as hardening outbox reliability, which involves adding features like locks, attempts, backoff, dead-letter queues, and metrics. I’ll provide a detailed implementation plan, including steps and necessary code-level changes.
**Enhancing system resilience**

Next, I’ll work on health readiness and startup/shutdown resilience by adding a `/readyz` endpoint for DB and Kafka checks, along with liveness probes and graceful shutdown processes. I'll implement Spring Boot Actuator for these tasks, focusing on idempotency with API requests to avoid duplicates. Then, I aim to improve observability by adding trace and log correlation, structured logs, and Grafana dashboards. It's crucial to ensure that the system can observe, recover, and maintain resilience through proper error handling and transactional outbox semantics.
**Drafting a task plan**

I should implement end-to-end chaos tests using Testcontainers or Docker Compose to kill services, but the user wants a plan, not an execution of tests. I’m also tasked with creating a curated TASKS-CURSOR.md that focuses on immediate tasks and next steps. The guidelines mention using the apply_patch tool for changes. Additionally, I’ll review the repo to assess existing implementations, like the loan-api code, focusing on outbox poller reliability. I plan to use semantic searches for terms like outbox, poller, readiness, and logging.
**Running multi-tool searches**

I plan to use multi_tool_use.parallel to run several codebase_search queries across the entire repository. I’ll look for information such as the implementation of the outbox poller, the configuration of the Kafka producer in the loan-api, the setup of OpenTelemetry/JSON logs, and whether health and readiness endpoints are configured. I also want to check where Kafka consumers are set up in the loan-notification-service and if idempotency is present. I'll need to inspect the results closely after running these searches.</details></think>

---

I'll search the codebase to locate the outbox poller, Kafka producer/consumer configs, health/readiness endpoints, and observability/logging setup to ground the resilience plan.

---

<details>
                <summary>Searched codebase "Where is the transactional outbox poller implemented in loan-api?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `loan-api/src/main/java/com/example/loan/api/config/OutboxPoller.java` | L19-46 |
| `loan-api/src/main/java/com/example/loan/api/config/OutboxPoller.java` | Lundefined-26 |
| `loan-api/src/main/java/com/example/loan/api/config/OutboxPoller.java` | L43-73 |
| `loan-api/src/main/java/com/example/loan/api/domain/service/OutboxWriter.java` | Lundefined-30 |
| `loan-api/src/test/java/com/example/loan/api/config/OutboxPollerTest.java` | Lundefined-49 |
| `loan-api/src/main/resources/application.yml` | Lundefined-35 |
| `loan-api/src/main/java/com/example/loan/api/domain/service/LoanService.java` | Lundefined-34 |
| `loan-api/src/main/java/com/example/loan/api/domain/service/LoanService.java` | L112-146 |
| `TASKS.md` | L154-182 |
| `loan-api/src/test/java/com/example/loan/api/it/LoanOutboxIT.java` | L28-74 |
| `TASKS.md` | L94-130 |
| `loan-api/src/main/java/com/example/loan/api/persistence/OutboxEventEntity.java` | Lundefined-33 |
| `loan-api/src/main/java/com/example/loan/api/persistence/OutboxEventRepository.java` | Lundefined-8 |
| `TASKS.md` | L37-66 |
| `TASKS.md` | L128-156 |

</details>

---

<details>
                <summary>Searched codebase "Where is Kafka producer configured and used in loan-api?" • **11** results</summary>
            
| File | Lines |
|------|-------|
| `loan-api/src/main/resources/application.yml` | Lundefined-35 |
| `loan-api/src/main/java/com/example/loan/api/config/KafkaConfig.java` | Lundefined-16 |
| `loan-api/src/main/resources/application-local.yml` | Lundefined-37 |
| `loan-api/src/main/java/com/example/loan/api/config/OutboxPoller.java` | L43-73 |
| `loan-api/pom.xml` | Lundefined-58 |
| `docker/docker-compose.yml` | L50-108 |
| `loan-api/src/test/java/com/example/loan/api/it/LoanOutboxIT.java` | L28-74 |
| `TASKS.md` | L128-156 |
| `loan-api/src/main/resources/logback-spring.xml` | Lundefined-15 |
| `loan-api/src/main/java/com/example/loan/api/config/OutboxPoller.java` | Lundefined-26 |
| `loan-notification-service/src/main/resources/application.yml` | Lundefined-12 |

</details>

---

<details>
                <summary>Searched codebase "Where are health or readiness endpoints configured (Actuator) in loan-api?" • **9** results</summary>
            
| File | Lines |
|------|-------|
| `README.md` | L61-116 |
| `loan-api/src/main/resources/application.yml` | Lundefined-35 |
| `README.md` | Lundefined-64 |
| `loan-api/src/main/java/com/example/loan/api/web/LoanApiController.java` | L45-55 |
| `docker/docker-compose.yml` | L50-108 |
| `TASKS.md` | L154-182 |
| `loan-api/src/main/resources/application-local.yml` | Lundefined-37 |
| `loan-api/pom.xml` | Lundefined-58 |
| `loan-notification-service/src/main/resources/application.yml` | Lundefined-12 |

</details>

---

<details>
                <summary>Searched codebase "Where is Kafka consumer implemented in loan-notification-service?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `loan-notification-service/src/main/java/com/example/loan/notification/LoanEventsConsumer.java` | Lundefined-17 |
| `loan-notification-service/src/main/resources/application.yml` | Lundefined-12 |
| `loan-notification-service/pom.xml` | Lundefined-44 |
| `loan-notification-service/src/main/resources/logback-spring.xml` | Lundefined-15 |
| `loan-notification-service/src/main/java/com/example/loan/notification/LoanNotificationServiceApplication.java` | Lundefined-10 |
| `loan-notification-service/src/test/java/com/example/loan/notification/LoanEventsConsumerTest.java` | Lundefined-41 |
| `loan-api/src/main/java/com/example/loan/api/config/KafkaConfig.java` | Lundefined-16 |
| `TASKS.md` | L94-130 |
| `loan-api/src/main/resources/application.yml` | Lundefined-35 |
| `docker/docker-compose.yml` | L50-108 |
| `loan-events/src/main/java/com/example/loan/events/LoanEvents.java` | Lundefined-6 |
| `TASKS.md` | L128-156 |
| `e2e/src/utils/kafka.ts` | L4-44 |

</details>

---

<details>
                <summary>Searched codebase "Where are JSON logging and OpenTelemetry agent configured?" • **1** results</summary>
            
| File | Lines |
|------|-------|
| `docker/alloy/config.alloy` | Lundefined-30 |

</details>

---

<think><details><summary>Thought Process</summary>**Planning task review and implementation**

I need to handle multiple tasks. First, I'll review TASKS.md and then create a new file called TASKS-CURSOR.md, containing only the necessary curated tasks after purging any unnecessary items. Importantly, I won’t modify TASKS.md; it should remain unchanged.

Next, I must review the repository and develop a detailed implementation plan for the top three tasks to enhance its resilience. It’s crucial to think deeply and propose three solid tasks.
**Analyzing OutboxPoller issues**

I've noticed that OutboxPoller has some significant shortcomings. It lacks locking and idempotence, using a blocking .get() within a scheduled task, which could lead to issues with double sending because there's no SKIP LOCKED or retry logic in place.

The application seems to miss producer properties in the application.yml, and there’s no dead-letter queue for handling errors. Additionally, the readiness endpoint isn't properly checking important components like the database or Kafka. Lastly, observability tasks appear incomplete; the current logging and traces features could be more robust.
**Proposing resilience tasks**

I’m drafting three key tasks aimed at enhancing resilience. 

First, we can focus on hardening the Outbox reliability by adding schema columns for attempts, locked_at, and sent_at, while implementing locking with a `FOR UPDATE SKIP LOCKED` query. This helps ensure exactly-once semantics using Kafka’s idempotence.

Second, improving consumer resilience will involve adding error handling features with Spring Kafka, like DeadLetterPublishingRecoverer. We'll also configure a dead-letter topic for logging and metrics.

Lastly, a thorough end-to-end test should be included to verify the dead-letter queue functionality.
**Focusing on readiness and resilience**

I need to implement a readiness endpoint, `/readyz`, within the Actuator to reflect the connectivity status of the database and Kafka. This should include liveness and readiness groups, with Flyway migrations factored in. I'll also ensure graceful shutdown handling and configure timeouts accordingly.

Additionally, I’m considering adding idempotency keys to the API for resilience, helping to avoid duplicate commands on retries. 

Ultimately, the top tasks for resilience will likely focus on Outbox hardening, enhancing Consumer DLQ and retry mechanisms, along with readiness, health checks, and graceful shutdowns. I'll also prepare a `TASKS-CURSOR.md` with curated essential tasks.
**Curating resilience tasks**

I’m focusing on essential tasks that enhance resilience and immediate improvements while following repo guidelines. I’ll use the code edit tools to create the `TASKS-CURSOR.md` file and implement a curated list of top tasks, ensuring to track them using the todo_write tool.

The content will feature the purpose, a curated task list emphasizing resilience, observability, and testing, and a detailed implementation plan for the top three tasks. These include hardening the transactional outbox, improving consumer resilience with DLQ, and refining health/readiness checks.

I won’t implement any code changes right now, just plan the tasks and file content.
**Deciding on curated tasks**

I need to finalize what to keep in our curated list, focusing on immediate resilience tasks and some secondary tasks related to observability and idempotency keys. 

I’ll create the `TASKS-CURSOR.md` file using the apply_patch tool to add this content to the repository. Following the todo flow, I'll set up two tasks: “Curate TASKS into TASKS-CURSOR.md” (marked in progress) and “Draft top 3 resilience implementation plans” (pending). 

Steps include adding both tasks, applying the patch, and marking them complete after saving. I’ll ensure to provide status updates along the way and craft the content carefully.</details></think>

---

Starting by creating a curated `TASKS-CURSOR.md` with a resilience-focused task list and detailed plans for the top three resilience tasks. Then I'll mark the todos as completed.

---

## Todo List

- [-] Curate TASKS into resilience-focused TASKS-CURSOR.md
- [ ] Draft detailed implementation plans for top 3 resilience tasks

---

I'll now create `TASKS-CURSOR.md` by extracting what's actionable and resilience-relevant from `TASKS.md`, and pruning redundant or outdated items.

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>**Planning task implementation**

I’m focusing on implementing a series of tasks: first, I need to review TASKS.md and then purge unnecessary items into TASKS-CURSOR.md. I plan to create this new file to curate just the essential tasks, removing redundancies. The user mentioned explicitly to create TASKS-CURSOR.md as another file rather than modifying TASKS.md. Also, I’ll use apply_patch as it's preferred for changes based on the repo rules. I'll keep in mind the guidelines about file organization.
**Analyzing improvement tasks**

I need to create three top tasks aimed at enhancing resilience, along with detailed implementation plans. First, I’m looking at outbox reliability enhancements, which include various strategies like locking with FOR UPDATE SKIP LOCKED or using advisory locks, retry attempts, and idempotence for the Kafka producer. This involves ensuring that the current process does not lead to duplicates if database transactions are rolled back. There’s no row locking happening currently, so I need to address that to prevent double publishing.
**Implementing crucial improvements**

Adding locking is essential for system reliability. I’m looking to implement readiness endpoints, specifically a /readyz actuator composite health check for both DB and Kafka connectivity. The app already has basic health endpoint /loans/healthz, but it needs this readiness check. 

Next, for consumer resilience, I’ll configure better error handling strategies, including a Dead Letter Queue (DLQ) and retries with backoff. Lastly, I'll enhance observability with improved OTel correlation by including trace IDs headers and adding a filter to parse traceparent headers on the consumer side.
**Focusing on resilience improvements**

I’m considering that Spring Kafka message headers may not include custom headers by default, but we can manually create spans. Idempotency on mutating endpoints is important for resilience to retries, but it might not be a top priority compared to outbox improvements, DLQ, and readiness checks. 

Database migrations for new columns are needed, and I’ll configure the Kafka producer with idempotence, acks=all, and retries set to infinite. The main tasks for resilience would include transactional outbox hardening with row-level locking, adding necessary columns, and implementing backoff strategies with DLQ routing.
**Drafting TASKS-CURSOR.md**

I need to create the TASKS-CURSOR.md file to purge unnecessary items while preserving only the essential tasks for resilience improvements. This will include detailing the top three tasks like transactional outbox reliability hardening, consumer resilience with DLQ, and readiness/liveness checks. 

The document will cover the purpose, scope, and goals, along with specific implementation plans that detail code changes, migrations, configurations, tests, and acceptance criteria. I’ll use apply_patch to create the file, ensuring indentation consistency for the Markdown format while updating the TODO list as I proceed.</details></think>

---

I curated and will now create `TASKS-CURSOR.md` with a resilience-focused plan, then update the todos to mark this step complete and start the planning task.

---



---

## Todo List

- [x] Curate TASKS into resilience-focused TASKS-CURSOR.md
- [-] Draft detailed implementation plans for top 3 resilience tasks

---

<think><details><summary>Thought Process</summary>**Planning repo improvements**

I need to review TASKS.md and purge unnecessary items into another file, TASKS-CURSOR.md. I've gone over TASKS.md and created TASKS-CURSOR.md with three detailed plans focused on resilience:  

1) Hardening Transactional Outbox Reliability with features like SKIP LOCKED and metrics.  
2) Enhancing Consumer resilience with retryable topics and error handling.  
3) Implementing readiness/liveness checks for graceful shutdowns.  

I’ll ensure we align with repository guidelines and propose any additional tasks, like end-to-end chaos tests, while continuously keeping the process moving until the problem is resolved.
**Updating task summary**

No code changes were requested except for creating the new file. I’m considering whether we should also update the Makefile or README, but the user only asked for a plan and task curation, so creating the file seems sufficient. It’s important to present a status update and brief summary per the spec. I'll summarize the top three tasks from the plan, ensuring the user can see it quickly in the chat. I can also provide a link to the created file and possibly cite relevant code lines, if necessary.
**Finalizing task updates**

I can include a small snippet from the top of TASKS-CURSOR.md, showing the first few lines for clarity. This snippet doesn't require a language tag, keeping it minimal. It's essential to maintain a concise update while providing status reports throughout the process. In my final message, I'll confirm that all tasks marked in progress are now complete and summarize everything. I'll check if we need to run lints, especially for any edited files, and address any linter errors if necessary.
**Evaluating lint needs**

It looks like there probably aren't any lints needed for the markdown file since the tool indicates it only returns linter errors for edited files, and markdown isn't typically covered. So, it seems reasonable to skip that step. I did create a new file and didn’t commit anything since the user didn’t ask for it. I’ll definitely clarify where the plans are located and mention that we pruned unnecessary tasks while keeping everything organized in TASKS-CURSOR.md. I also reviewed the repo and included relevant details in the plan.
**Completing the second task**

I need to mark the second todo item as completed, so I’ll call todo_write with merge=true. After that, I’ll provide a brief summary that lists the top three tasks in bullet points while adhering to markdown formatting, using headings and bold pseudo-headings. I won't include a code citation, even though it could be nice, since the instructions allow for omitting it to keep things minimal. I’ll simply reference the file path and finalize marking the todo as complete.</details></think>

---

Marking the planning task as complete, then summarizing the top three resilience tasks and where to find the detailed plans.

---

## Todo List

- [x] Curate TASKS into resilience-focused TASKS-CURSOR.md
- [x] Draft detailed implementation plans for top 3 resilience tasks

---

- I scanned `TASKS.md`, the codebase, and created `TASKS-CURSOR.md` focused on resilience. I completed both todos and captured detailed plans for the top three hardening tasks.

### What I delivered
- TASKS-CURSOR.md now contains:
  - Top 3 next resilience tasks with detailed implementation steps, acceptance criteria, and impacted files:
    1) Transactional Outbox Reliability Hardening in `loan-api` (row claiming with SKIP LOCKED, attempts/backoff, idempotent producer, DLQ, metrics, tests).
    2) Consumer Resilience in `loan-notification-service` (retryable topics, backoff, DLT, error handling, tracing, metrics, tests).
    3) Readiness/Liveness and Graceful Shutdown across services (health groups requiring DB/Kafka, graceful shutdown, probe docs, tests).
  - A trimmed secondary backlog aligned with resilience (idempotency keys, outbox TTL cleanup, chaos tests, Grafana panels).
  - Direct pointers to relevant files in the repo.

You can review the curated plan in `TASKS-CURSOR.md`.

---

